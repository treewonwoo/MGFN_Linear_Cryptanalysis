/*-----------------------------------------------------------------------------
 * MGFN_18R.c — implementation file
 * ---------------------------------------------------------------------------
 * This source file holds the concrete definitions for the tables, S‑box, and
 * every function declared in **MGFN_18R.h** (see header for API details).
 *----------------------------------------------------------------------------*/

#include "MGFN_18R.h"
#include <string.h>
#include <omp.h>

 /* -------------------------------------------------------------------------- */
 /*  Global lookup tables                                                      */
 /* -------------------------------------------------------------------------- */

 /* 4‑bit S‑box */
uint8_t S[SBOX_SIZE] = {
    0x7, 0xE, 0xF, 0x0, 0xD, 0xB, 0x8, 0x1,
    0x9, 0x3, 0x4, 0xC, 0x2, 0x5, 0xA, 0x6
};

/* Pre‑computed 8‑bit T‑tables (excerpt below to keep this demo concise).     */
/* Replace the ellipsis with full 256‑entry tables from your original code.   */
const uint32_t te1[256] = { 0x40431400, 0x40411408, 0x40431408, 0x40010400, 0x40430408, 0x40031408, 0x40010408, 0x40030400, 0x40030408, 0x40031400, 0x40410400, 0x40410408, 0x40011400, 0x40430400, 0x40011408, 0x40411400, 0x48421400, 0x48401408, 0x48421408, 0x48000400, 0x48420408, 0x48021408, 0x48000408, 0x48020400, 0x48020408, 0x48021400, 0x48400400, 0x48400408, 0x48001400, 0x48420400, 0x48001408, 0x48401400, 0x48431400, 0x48411408, 0x48431408, 0x48010400, 0x48430408, 0x48031408, 0x48010408, 0x48030400, 0x48030408, 0x48031400, 0x48410400, 0x48410408, 0x48011400, 0x48430400, 0x48011408, 0x48411400, 0x00421000, 0x00401008, 0x00421008, 0x00000000, 0x00420008, 0x00021008, 0x00000008, 0x00020000, 0x00020008, 0x00021000, 0x00400000, 0x00400008, 0x00001000, 0x00420000, 0x00001008, 0x00401000, 0x08431400, 0x08411408, 0x08431408, 0x08010400, 0x08430408, 0x08031408, 0x08010408, 0x08030400, 0x08030408, 0x08031400, 0x08410400, 0x08410408, 0x08011400, 0x08430400, 0x08011408, 0x08411400, 0x48431000, 0x48411008, 0x48431008, 0x48010000, 0x48430008, 0x48031008, 0x48010008, 0x48030000, 0x48030008, 0x48031000, 0x48410000, 0x48410008, 0x48011000, 0x48430000, 0x48011008, 0x48411000, 0x08421000, 0x08401008, 0x08421008, 0x08000000, 0x08420008, 0x08021008, 0x08000008, 0x08020000, 0x08020008, 0x08021000, 0x08400000, 0x08400008, 0x08001000, 0x08420000, 0x08001008, 0x08401000, 0x00431000, 0x00411008, 0x00431008, 0x00010000, 0x00430008, 0x00031008, 0x00010008, 0x00030000, 0x00030008, 0x00031000, 0x00410000, 0x00410008, 0x00011000, 0x00430000, 0x00011008, 0x00411000, 0x08431000, 0x08411008, 0x08431008, 0x08010000, 0x08430008, 0x08031008, 0x08010008, 0x08030000, 0x08030008, 0x08031000, 0x08410000, 0x08410008, 0x08011000, 0x08430000, 0x08011008, 0x08411000, 0x40431000, 0x40411008, 0x40431008, 0x40010000, 0x40430008, 0x40031008, 0x40010008, 0x40030000, 0x40030008, 0x40031000, 0x40410000, 0x40410008, 0x40011000, 0x40430000, 0x40011008, 0x40411000, 0x00421400, 0x00401408, 0x00421408, 0x00000400, 0x00420408, 0x00021408, 0x00000408, 0x00020400, 0x00020408, 0x00021400, 0x00400400, 0x00400408, 0x00001400, 0x00420400, 0x00001408, 0x00401400, 0x08421400, 0x08401408, 0x08421408, 0x08000400, 0x08420408, 0x08021408, 0x08000408, 0x08020400, 0x08020408, 0x08021400, 0x08400400, 0x08400408, 0x08001400, 0x08420400, 0x08001408, 0x08401400, 0x40421000, 0x40401008, 0x40421008, 0x40000000, 0x40420008, 0x40021008, 0x40000008, 0x40020000, 0x40020008, 0x40021000, 0x40400000, 0x40400008, 0x40001000, 0x40420000, 0x40001008, 0x40401000, 0x00431400, 0x00411408, 0x00431408, 0x00010400, 0x00430408, 0x00031408, 0x00010408, 0x00030400, 0x00030408, 0x00031400, 0x00410400, 0x00410408, 0x00011400, 0x00430400, 0x00011408, 0x00411400, 0x48421000, 0x48401008, 0x48421008, 0x48000000, 0x48420008, 0x48021008, 0x48000008, 0x48020000, 0x48020008, 0x48021000, 0x48400000, 0x48400008, 0x48001000, 0x48420000, 0x48001008, 0x48401000, 0x40421400, 0x40401408, 0x40421408, 0x40000400, 0x40420408, 0x40021408, 0x40000408, 0x40020400, 0x40020408, 0x40021400, 0x40400400, 0x40400408, 0x40001400, 0x40420400, 0x40001408, 0x40401400 };

const uint32_t te2[256] = { 0x8100A220, 0x0120A220, 0x8120A220, 0x01002200, 0x8120A200, 0x81202220, 0x01202200, 0x81002200, 0x81202200, 0x81002220, 0x0100A200, 0x0120A200, 0x01002220, 0x8100A200, 0x01202220, 0x0100A220, 0x8100A060, 0x0120A060, 0x8120A060, 0x01002040, 0x8120A040, 0x81202060, 0x01202040, 0x81002040, 0x81202040, 0x81002060, 0x0100A040, 0x0120A040, 0x01002060, 0x8100A040, 0x01202060, 0x0100A060, 0x8100A260, 0x0120A260, 0x8120A260, 0x01002240, 0x8120A240, 0x81202260, 0x01202240, 0x81002240, 0x81202240, 0x81002260, 0x0100A240, 0x0120A240, 0x01002260, 0x8100A240, 0x01202260, 0x0100A260, 0x80008020, 0x00208020, 0x80208020, 0x00000000, 0x80208000, 0x80200020, 0x00200000, 0x80000000, 0x80200000, 0x80000020, 0x00008000, 0x00208000, 0x00000020, 0x80008000, 0x00200020, 0x00008020, 0x81008260, 0x01208260, 0x81208260, 0x01000240, 0x81208240, 0x81200260, 0x01200240, 0x81000240, 0x81200240, 0x81000260, 0x01008240, 0x01208240, 0x01000260, 0x81008240, 0x01200260, 0x01008260, 0x8000A260, 0x0020A260, 0x8020A260, 0x00002240, 0x8020A240, 0x80202260, 0x00202240, 0x80002240, 0x80202240, 0x80002260, 0x0000A240, 0x0020A240, 0x00002260, 0x8000A240, 0x00202260, 0x0000A260, 0x80008060, 0x00208060, 0x80208060, 0x00000040, 0x80208040, 0x80200060, 0x00200040, 0x80000040, 0x80200040, 0x80000060, 0x00008040, 0x00208040, 0x00000060, 0x80008040, 0x00200060, 0x00008060, 0x80008220, 0x00208220, 0x80208220, 0x00000200, 0x80208200, 0x80200220, 0x00200200, 0x80000200, 0x80200200, 0x80000220, 0x00008200, 0x00208200, 0x00000220, 0x80008200, 0x00200220, 0x00008220, 0x80008260, 0x00208260, 0x80208260, 0x00000240, 0x80208240, 0x80200260, 0x00200240, 0x80000240, 0x80200240, 0x80000260, 0x00008240, 0x00208240, 0x00000260, 0x80008240, 0x00200260, 0x00008260, 0x8000A220, 0x0020A220, 0x8020A220, 0x00002200, 0x8020A200, 0x80202220, 0x00202200, 0x80002200, 0x80202200, 0x80002220, 0x0000A200, 0x0020A200, 0x00002220, 0x8000A200, 0x00202220, 0x0000A220, 0x81008020, 0x01208020, 0x81208020, 0x01000000, 0x81208000, 0x81200020, 0x01200000, 0x81000000, 0x81200000, 0x81000020, 0x01008000, 0x01208000, 0x01000020, 0x81008000, 0x01200020, 0x01008020, 0x81008060, 0x01208060, 0x81208060, 0x01000040, 0x81208040, 0x81200060, 0x01200040, 0x81000040, 0x81200040, 0x81000060, 0x01008040, 0x01208040, 0x01000060, 0x81008040, 0x01200060, 0x01008060, 0x8000A020, 0x0020A020, 0x8020A020, 0x00002000, 0x8020A000, 0x80202020, 0x00202000, 0x80002000, 0x80202000, 0x80002020, 0x0000A000, 0x0020A000, 0x00002020, 0x8000A000, 0x00202020, 0x0000A020, 0x81008220, 0x01208220, 0x81208220, 0x01000200, 0x81208200, 0x81200220, 0x01200200, 0x81000200, 0x81200200, 0x81000220, 0x01008200, 0x01208200, 0x01000220, 0x81008200, 0x01200220, 0x01008220, 0x8000A060, 0x0020A060, 0x8020A060, 0x00002040, 0x8020A040, 0x80202060, 0x00202040, 0x80002040, 0x80202040, 0x80002060, 0x0000A040, 0x0020A040, 0x00002060, 0x8000A040, 0x00202060, 0x0000A060, 0x8100A020, 0x0120A020, 0x8120A020, 0x01002000, 0x8120A000, 0x81202020, 0x01202000, 0x81002000, 0x81202000, 0x81002020, 0x0100A000, 0x0120A000, 0x01002020, 0x8100A000, 0x01202020, 0x0100A020 };

const uint32_t te3[256] = { 0x24104102, 0x34100102, 0x34104102, 0x20100100, 0x30104102, 0x34104100, 0x30100100, 0x20104100, 0x30104100, 0x24104100, 0x20100102, 0x30100102, 0x24100100, 0x20104102, 0x34100100, 0x24100102, 0x24004103, 0x34000103, 0x34004103, 0x20000101, 0x30004103, 0x34004101, 0x30000101, 0x20004101, 0x30004101, 0x24004101, 0x20000103, 0x30000103, 0x24000101, 0x20004103, 0x34000101, 0x24000103, 0x24104103, 0x34100103, 0x34104103, 0x20100101, 0x30104103, 0x34104101, 0x30100101, 0x20104101, 0x30104101, 0x24104101, 0x20100103, 0x30100103, 0x24100101, 0x20104103, 0x34100101, 0x24100103, 0x04004002, 0x14000002, 0x14004002, 0x00000000, 0x10004002, 0x14004000, 0x10000000, 0x00004000, 0x10004000, 0x04004000, 0x00000002, 0x10000002, 0x04000000, 0x00004002, 0x14000000, 0x04000002, 0x24104003, 0x34100003, 0x34104003, 0x20100001, 0x30104003, 0x34104001, 0x30100001, 0x20104001, 0x30104001, 0x24104001, 0x20100003, 0x30100003, 0x24100001, 0x20104003, 0x34100001, 0x24100003, 0x04104103, 0x14100103, 0x14104103, 0x00100101, 0x10104103, 0x14104101, 0x10100101, 0x00104101, 0x10104101, 0x04104101, 0x00100103, 0x10100103, 0x04100101, 0x00104103, 0x14100101, 0x04100103, 0x04004003, 0x14000003, 0x14004003, 0x00000001, 0x10004003, 0x14004001, 0x10000001, 0x00004001, 0x10004001, 0x04004001, 0x00000003, 0x10000003, 0x04000001, 0x00004003, 0x14000001, 0x04000003, 0x04104002, 0x14100002, 0x14104002, 0x00100000, 0x10104002, 0x14104000, 0x10100000, 0x00104000, 0x10104000, 0x04104000, 0x00100002, 0x10100002, 0x04100000, 0x00104002, 0x14100000, 0x04100002, 0x04104003, 0x14100003, 0x14104003, 0x00100001, 0x10104003, 0x14104001, 0x10100001, 0x00104001, 0x10104001, 0x04104001, 0x00100003, 0x10100003, 0x04100001, 0x00104003, 0x14100001, 0x04100003, 0x04104102, 0x14100102, 0x14104102, 0x00100100, 0x10104102, 0x14104100, 0x10100100, 0x00104100, 0x10104100, 0x04104100, 0x00100102, 0x10100102, 0x04100100, 0x00104102, 0x14100100, 0x04100102, 0x24004002, 0x34000002, 0x34004002, 0x20000000, 0x30004002, 0x34004000, 0x30000000, 0x20004000, 0x30004000, 0x24004000, 0x20000002, 0x30000002, 0x24000000, 0x20004002, 0x34000000, 0x24000002, 0x24004003, 0x34000003, 0x34004003, 0x20000001, 0x30004003, 0x34004001, 0x30000001, 0x20004001, 0x30004001, 0x24004001, 0x20000003, 0x30000003, 0x24000001, 0x20004003, 0x34000001, 0x24000003, 0x04004102, 0x14000102, 0x14004102, 0x00000100, 0x10004102, 0x14004100, 0x10000100, 0x00004100, 0x10004100, 0x04004100, 0x00000102, 0x10000102, 0x04000100, 0x00004102, 0x14000100, 0x04000102, 0x24104002, 0x34100002, 0x34104002, 0x20100000, 0x30104002, 0x34104000, 0x30100000, 0x20104000, 0x30104000, 0x24104000, 0x20100002, 0x30100002, 0x24100000, 0x20104002, 0x34100000, 0x24100002, 0x04004103, 0x14000103, 0x14004103, 0x00000101, 0x10004103, 0x14004101, 0x10000101, 0x00004101, 0x10004101, 0x04004101, 0x00000103, 0x10000103, 0x04000101, 0x00004103, 0x14000101, 0x04000103, 0x24004102, 0x34000102, 0x34004102, 0x20000100, 0x30004102, 0x34004100, 0x30000100, 0x20004100, 0x30004100, 0x24004100, 0x20000102, 0x30000102, 0x24000100, 0x20004102, 0x34000100, 0x24000102 };

const uint32_t te4[256] = { 0x008C0814, 0x008C0884, 0x008C0894, 0x00880004, 0x008C0094, 0x00880894, 0x00880084, 0x00880014, 0x00880094, 0x00880814, 0x008C0004, 0x008C0084, 0x00880804, 0x008C0014, 0x00880884, 0x008C0804, 0x020C0814, 0x020C0884, 0x020C0894, 0x02080004, 0x020C0094, 0x02080894, 0x02080084, 0x02080014, 0x02080094, 0x02080814, 0x020C0004, 0x020C0084, 0x02080804, 0x020C0014, 0x02080884, 0x020C0804, 0x028C0814, 0x028C0884, 0x028C0894, 0x02880004, 0x028C0094, 0x02880894, 0x02880084, 0x02880014, 0x02880094, 0x02880814, 0x028C0004, 0x028C0084, 0x02880804, 0x028C0014, 0x02880884, 0x028C0804, 0x00040810, 0x00040880, 0x00040890, 0x00000000, 0x00040090, 0x00000890, 0x00000080, 0x00000010, 0x00000090, 0x00000810, 0x00040000, 0x00040080, 0x00000800, 0x00040010, 0x00000880, 0x00040800, 0x02840814, 0x02840884, 0x02840894, 0x02800004, 0x02840094, 0x02800894, 0x02800084, 0x02800014, 0x02800094, 0x02800814, 0x02840004, 0x02840084, 0x02800804, 0x02840014, 0x02800884, 0x02840804, 0x028C0810, 0x028C0880, 0x028C0890, 0x02880000, 0x028C0090, 0x02880890, 0x02880080, 0x02880010, 0x02880090, 0x02880810, 0x028C0000, 0x028C0080, 0x02880800, 0x028C0010, 0x02880880, 0x028C0800, 0x02040810, 0x02040880, 0x02040890, 0x02000000, 0x02040090, 0x02000890, 0x02000080, 0x02000010, 0x02000090, 0x02000810, 0x02040000, 0x02040080, 0x02000800, 0x02040010, 0x02000880, 0x02040800, 0x00840810, 0x00840880, 0x00840890, 0x00800000, 0x00840090, 0x00800890, 0x00800080, 0x00800010, 0x00800090, 0x00800810, 0x00840000, 0x00840080, 0x00800800, 0x00840010, 0x00800880, 0x00840800, 0x02840810, 0x02840880, 0x02840890, 0x02800000, 0x02840090, 0x02800890, 0x02800080, 0x02800010, 0x02800090, 0x02800810, 0x02840000, 0x02840080, 0x02800800, 0x02840010, 0x02800880, 0x02840800, 0x008C0810, 0x008C0880, 0x008C0890, 0x00880000, 0x008C0090, 0x00880890, 0x00880080, 0x00880010, 0x00880090, 0x00880810, 0x008C0000, 0x008C0080, 0x00880800, 0x008C0010, 0x00880880, 0x008C0800, 0x00040814, 0x00040884, 0x00040894, 0x00000004, 0x00040094, 0x00000894, 0x00000084, 0x00000014, 0x00000094, 0x00000814, 0x00040004, 0x00040084, 0x00000804, 0x00040014, 0x00000884, 0x00040804, 0x02040814, 0x02040884, 0x02040894, 0x02000004, 0x02040094, 0x02000894, 0x02000084, 0x02000014, 0x02000094, 0x02000814, 0x02040004, 0x02040084, 0x02000804, 0x02040014, 0x02000884, 0x02040804, 0x000C0810, 0x000C0880, 0x000C0890, 0x00080000, 0x000C0090, 0x00080890, 0x00080080, 0x00080010, 0x00080090, 0x00080810, 0x000C0000, 0x000C0080, 0x00080800, 0x000C0010, 0x00080880, 0x000C0800, 0x00840814, 0x00840884, 0x00840894, 0x00800004, 0x00840094, 0x00800894, 0x00800084, 0x00800014, 0x00800094, 0x00800814, 0x00840004, 0x00840084, 0x00800804, 0x00840014, 0x00800884, 0x00840804, 0x020C0810, 0x020C0880, 0x020C0890, 0x02080000, 0x020C0090, 0x02080890, 0x02080080, 0x02080010, 0x02080090, 0x02080810, 0x020C0000, 0x020C0080, 0x02080800, 0x020C0010, 0x02080880, 0x020C0800, 0x000C0814, 0x000C0884, 0x000C0894, 0x00080004, 0x000C0094, 0x00080894, 0x00080084, 0x00080014, 0x00080094, 0x00080814, 0x000C0004, 0x000C0084, 0x00080804, 0x000C0014, 0x00080884, 0x000C0804 };


/* -------------------------------------------------------------------------- */
/*  Helper routines                                                           */
/* -------------------------------------------------------------------------- */

void split_master_key(
    uint8_t* master_key,
    uint64_t* high,
    uint64_t* low
) {
    *high = ((uint64_t)master_key[0] << 56) |
        ((uint64_t)master_key[1] << 48) |
        ((uint64_t)master_key[2] << 40) |
        ((uint64_t)master_key[3] << 32) |
        ((uint64_t)master_key[4] << 24) |
        ((uint64_t)master_key[5] << 16) |
        ((uint64_t)master_key[6] << 8) |
        (uint64_t)master_key[7];

    *low = ((uint64_t)master_key[8] << 56) |
        ((uint64_t)master_key[9] << 48) |
        ((uint64_t)master_key[10] << 40) |
        ((uint64_t)master_key[11] << 32) |
        ((uint64_t)master_key[12] << 24) |
        ((uint64_t)master_key[13] << 16) |
        ((uint64_t)master_key[14] << 8) |
        (uint64_t)master_key[15];
}

void rotate_right_61_bits(
    uint64_t* high,
    uint64_t* low
) {
    uint64_t low_masked = *low & 0x1FFFFFFFFFFFFFFFULL;
    uint64_t high_masked = *high & 0x1FFFFFFFFFFFFFFFULL;

    *high = (low_masked << 3) | (*high >> 61);
    *low = (high_masked << 3) | (*low >> 61);
}

void rotate_right_67_bits(
    uint64_t* high,
    uint64_t* low
) {
    uint64_t low_masked = *low & 0xFFFFFFFFFFFFFFF8ULL;
    uint64_t high_masked = *high & 0xFFFFFFFFFFFFFFF8ULL;

    *high = (low_masked >> 3) | (*high << 61);
    *low = (high_masked >> 3) | (*low << 61);
}

uint8_t substitute_with_sbox(uint8_t nibble) {
    return S[nibble & 0xF];
}

/* -------------------------------------------------------------------------- */
/*  Key‑schedule generation                                                   */
/* -------------------------------------------------------------------------- */

void key_schedule(
    uint8_t* mk,
    KeySchedule* ks
) {
    uint64_t hi, lo;
    split_master_key(mk, &hi, &lo);

    int rk_idx = 0;
    for (int rc = 0; rc < 11; ++rc) {
        uint64_t Ki_hi = hi, Ki_lo = lo;
        rotate_right_61_bits(&Ki_hi, &Ki_lo);
        ks->round_keys[rc] = Ki_hi;

        if (rc == 0) {
            ks->rk[rk_idx++] = ks->round_keys[rc];
        }
        else if (rc < 10) {
            ks->rk[rk_idx++] = ks->round_keys[rc] >> 32;
            ks->rk[rk_idx++] = ks->round_keys[rc] & 0xFFFFFFFFULL;
        }
        else {
            ks->rk[rk_idx++] = ks->round_keys[rc];
        }

        rotate_right_67_bits(&hi, &lo);

        uint8_t n0 = (hi >> 60) & 0xF;
        uint8_t n1 = (hi >> 56) & 0xF;
        hi &= 0x00FFFFFFFFFFFFFFULL;
        hi |= (uint64_t)S[n0] << 60;
        hi |= (uint64_t)S[n1] << 56;

        uint8_t rc4 = (rc + 1) & 0xF;
        hi ^= (rc4 >> 2) & 0x3;
        lo ^= (uint64_t)(rc4 & 0x3) << 62;
    }

}

/* -------------------------------------------------------------------------- */
/*  Encryption primitives                                                     */
/* -------------------------------------------------------------------------- */

uint64_t Table_lookup(uint64_t input) {
    uint8_t b1 = (uint8_t)((((input >> 16) & 0x7) << 5) | ((input >> 27) & 0x1F));
    uint8_t b2 = (uint8_t)((input >> 19) & 0xFF);
    uint8_t b3 = (uint8_t)(input & 0xFF);
    uint8_t b4 = (uint8_t)((input >> 8) & 0xFF);

    return te1[b1] ^ te2[b2] ^ te3[b3] ^ te4[b4];
}

uint64_t encrypt_single_round(
    uint64_t P,
    uint64_t key
) {
    uint64_t P_H = (P >> 32) & 0xFFFFFFFFULL;
    uint64_t P_L = P & 0xFFFFFFFFULL;

    uint64_t Updated_P_H = Table_lookup(P_H ^ key) ^ P_L;
    return (Updated_P_H << 32) | P_H; /* swap halves */
}

void encrypt(
    uint64_t plaintext,
    KeySchedule* key_schedule,
    uint64_t* ciphertext
) {
    uint64_t state = plaintext ^ key_schedule->rk[0];

    for (int i = 0; i < 18; ++i) {
        state = encrypt_single_round(state, key_schedule->rk[i + 1]);
    }

    *ciphertext = state ^ key_schedule->rk[19];
}

/* -------------------------------------------------------------------------- */
/*  Utilities                                                                 */
/* -------------------------------------------------------------------------- */

void save_to_file(
    FILE* file,
    uint64_t plaintext,
    uint64_t ciphertext
) {
    fprintf(file, "%016llX %016llX\n", plaintext, ciphertext);
}

void generate_random_data(uint64_t* data) {
    unsigned int r1 = 0, r2 = 0;
    if (rand_s(&r1) || rand_s(&r2)) {
        *data = 0ULL; /* fallback */
    }
    else {
        *data = ((uint64_t)r1 << 32) | r2;
    }
}

uint32_t array_to_int(uint8_t* bit_list) {
    uint32_t res = 0;
    for (int i = 0; i < 32; ++i) {
        res |= ((uint32_t)bit_list[i] << (31 - i));
    }
    return res;
}

uint32_t convert_key_array_to_uint32(uint8_t right_keys[9]) {
    uint16_t upper = 0;
    upper |= (right_keys[8] << 12);
    upper |= (right_keys[7] << 8);
    upper |= (right_keys[6] << 4);
    upper |= (right_keys[5]);
    upper = (upper << 3) | (upper >> 13);

    uint16_t lower = 0;
    lower |= (right_keys[2] << 12);
    lower |= (right_keys[1] << 8);
    lower |= (right_keys[4] << 4);
    lower |= (right_keys[3]);

    return ((uint32_t)upper << 16) | lower;
}

/* -------------------------------------------------------------------------- */
/*  Decryption helpers                                                        */
/* -------------------------------------------------------------------------- */

#define SPLIT_CIPHERTEXT(ct, CH, CL)     \
    uint64_t CH = ((ct) >> 32) & 0xFFFFFFFFULL; \
    uint64_t CL =  (ct)        & 0xFFFFFFFFULL

uint32_t decrypt_half_one_round(
    uint64_t ciphertext1,
    uint8_t rk24_xor_k14[9]
) {
    uint32_t rk24 = convert_key_array_to_uint32(rk24_xor_k14);
    SPLIT_CIPHERTEXT(ciphertext1, C_H, C_L);
    uint64_t upd = Table_lookup(C_L ^ rk24);
    return (uint32_t)(upd ^ C_H);
}

uint32_t decrypt_half_one_round1(
    uint64_t ciphertext1,
    uint32_t rk24_xor_k14
) {
    SPLIT_CIPHERTEXT(ciphertext1, C_H, C_L);
    uint64_t upd = Table_lookup(C_L ^ rk24_xor_k14);
    return (uint32_t)(upd ^ C_H);
}

uint32_t decrypt_half_two_round(
    uint64_t ciphertext1,
    uint8_t rk24_xor_k14[9],
    uint8_t rk23_xor_k14[9]
) {
    uint32_t rk24 = convert_key_array_to_uint32(rk24_xor_k14);
    uint32_t rk23 = convert_key_array_to_uint32(rk23_xor_k14);

    SPLIT_CIPHERTEXT(ciphertext1, C_H, C_L);

    uint64_t upd1 = Table_lookup(C_L ^ rk24);
    uint64_t upd2 = Table_lookup(upd1 ^ C_H ^ rk23);

    return (uint32_t)(upd2 ^ C_L);
}

uint32_t decrypt_half_three_round(
    uint64_t ciphertext1,
    uint8_t rk24_xor_k14[9],
    uint8_t rk23_xor_k14[9],
    uint8_t rk22_xor_k14[9]
) {
    uint32_t rk24 = convert_key_array_to_uint32(rk24_xor_k14);
    uint32_t rk23 = convert_key_array_to_uint32(rk23_xor_k14);
    uint32_t rk22 = convert_key_array_to_uint32(rk22_xor_k14);

    SPLIT_CIPHERTEXT(ciphertext1, C_H, C_L);

    uint64_t upd1 = Table_lookup(C_L ^ rk24);
    uint64_t upd2 = Table_lookup(upd1 ^ C_H ^ rk23);
    uint64_t upd3 = Table_lookup(upd2 ^ C_L ^ rk22);

    return (uint32_t)(upd3 ^ upd1 ^ C_H);
}

/* -------------------------------------------------------------------------- */
/*  End of file                                                               */
/* -------------------------------------------------------------------------- */
